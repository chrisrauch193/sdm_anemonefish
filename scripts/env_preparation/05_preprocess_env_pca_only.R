# scripts/env_preparation/05_preprocess_env_pca_only.R
#-------------------------------------------------------------------------------
# Preprocess Environmental Data using PCA Only - v4 (Jim√©nez et al. inspired pre-selection)
#
# 1. Loads ALL relevant current environmental + terrain layers.
# 2. Subsets to a pre-defined list of 8 oceanographic variables for PCA.
# 3. **Crops** selected current layers to Indo-Pacific extent (if configured).
# 4. **Masks** the sampling layer (first of selected) to coral reefs (if configured).
# 5. Samples background points from the cropped/masked layer.
# 6. Extracts values at points & builds ONE PCA model (using stats::prcomp) from the 8 selected variables.
# 7. Projects this PCA model onto the CURRENT and ALL FUTURE environmental stacks
#    (after subsetting future stacks to the corresponding 8 variables and cropping).
# 8. Saves the PCA raster stacks and paths for use in SDM scripts.
#-------------------------------------------------------------------------------

cat("--- Running Script 05_preprocess_env_pca_only.R: PCA Preprocessing (v4 - Pre-selection of 8 Env Vars) ---\n")

# --- 1. Setup ---
if (!exists("config")) { source("scripts/config.R"); if (!exists("config")) stop("Failed load config.") }
pacman::p_load(terra, sf, dplyr, readr, stats, tools, stringr)

env_helper_path <- file.path(config$helpers_dir, "env_processing_helpers.R")
if (!file.exists(env_helper_path)) stop("Env Helper missing.")
source(env_helper_path)

# --- 2. Define Target Environmental Variables for PCA (CURRENT SCENARIO NAMES) ---
# IMPORTANT: These names MUST match the layer names generated by `load_stack_env_data`
# for the "current" scenario (i.e., filenames without .tif).
# You will need to verify and adjust these based on your actual Bio-ORACLE downloads.
#
# Based on your list: "mean current velocity, mean salinity, mean temperature,
# mean nitrate concentration, nitrate concentration range, mean chlorophyll concentration,
# dissolved oxygen con- centration range, and mean phytoplankton concentration."

target_env_vars_current_names <- c(
  # "current_velocity_mean",        # Placeholder - VERIFY THIS NAME from your files. Bio-ORACLE gives uo, vo.
  # "sws_baseline_depthsurf_mean",
  # You might need to calculate speed: sqrt(uo_mean^2 + vo_mean^2) and save as a layer.
  "so_baseline_depthmax_mean", # Mean Salinity (assuming bottom)
  "thetao_baseline_depthmax_mean", # Mean Temperature (assuming bottom)
  "no3_baseline_depthmax_mean",   # Mean Nitrate Concentration (assuming bottom)
  "no3_baseline_depthmax_range",  # Nitrate Concentration Range (assuming bottom)
  "chl_baseline_depthmax_mean",   # Mean Chlorophyll Concentration (assuming bottom)
  "o2_baseline_depthmax_range",   # Dissolved Oxygen Concentration Range (assuming bottom)
  "phyc_baseline_depthmax_mean",   # Mean Phytoplankton Concentration (assuming bottom)
  # NOTE: Terrain variables are NOT included in this list for PCA as per your specified 8.
  # If you want terrain vars in the PCA, add their names here (e.g., "bathymetry_mean", "slope", etc.)
  "bathymetry_mean", "distcoast",
  # "rugosity",
  
  "par_baseline_depthsurf_mean"
  # "thetao_baseline_depthmax_range",
  # "ph_baseline_depthmax_mean"
)

# # anemone
# target_env_vars_current_names <- c(
#   "par_baseline_depthsurf_mean",
#   "sws_baseline_depthsurf_mean",
#   "thetao_baseline_depthmax_mean",
#   "thetao_baseline_depthmax_range",
#   "so_baseline_depthmax_mean",
#   "no3_baseline_depthmax_mean",
#   "no3_baseline_depthmax_range",
#   "chl_baseline_depthmax_mean",
#   "o2_baseline_depthmax_range",
#   # Terrain Vars
#   "bathymetry_mean", "distcoast", "rugosity"
# )
# 
# # anemonefish
# target_env_vars_current_names <- c(
#   "par_baseline_depthsurf_mean",
#   "sws_baseline_depthsurf_mean",
#   "thetao_baseline_depthmax_mean",
#   "thetao_baseline_depthmax_range",
#   "so_baseline_depthmax_mean",
#   "no3_baseline_depthmax_mean",
#   "no3_baseline_depthmax_range",
#   "chl_baseline_depthmax_mean",
#   "o2_baseline_depthmax_range",
#   # "o2_baseline_depthmax_ltmin",
#   # "ph_baseline_depthmax_mean",
#   # Terrain Vars
#   "bathymetry_mean", "distcoast", "rugosity"
# )
# 
# # Combined
# core_env_vars_fish_combined <- c(
#   # --- PASTE Your Final Non-Collinear ENV VARS from 05b 'current' analysis ---
#   # Example:
#   "thetao_baseline_depthmax_mean",
#   "so_baseline_depthmax_mean",
#   "no3_baseline_depthmax_mean",
#   "chl_baseline_depthmax_mean",
#   "o2_baseline_depthmax_range",
#   "par_baseline_depthsurf_mean",
#   "sws_baseline_depthsurf_mean",
#   "bathymetry_mean",
#   "distcoast",
#   "rugosity"
#   # --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
# )
# 

# 
# 
# # General ones
# c(
#   "par_baseline_depthsurf_mean",
#   "sws_baseline_depthsurf_mean",
#   "thetao_baseline_depthmax_mean",
#   "thetao_baseline_depthmax_range",
#   "so_baseline_depthmax_mean",
#   "no3_baseline_depthmax_mean",
#   "no3_baseline_depthmax_range",
#   "chl_baseline_depthmax_mean",
#   "o2_baseline_depthmax_range",
#   "bathymetry_mean",
#   "distcoast",
#   "rugosity"
# )


cat("--- Target variables for PCA:", paste(target_env_vars_current_names, collapse=", "), "---\n")
if(length(target_env_vars_current_names) < 2) stop("At least 2 target environmental variables must be defined for PCA.")


# --- 3. Load ALL CURRENT Env Data, then SUBSET ---
cat("--- Loading ALL relevant current environmental layers (will subset later) ---\n")
current_scenario_name <- "current"
all_variables_stack_current_raw <- load_stack_env_data(current_scenario_name, config)

if(is.null(all_variables_stack_current_raw) || terra::nlyr(all_variables_stack_current_raw) < 2) {
  stop("Failed to load sufficient current environmental layers.")
}
cat("  Loaded raw current environmental stack with layers:", paste(names(all_variables_stack_current_raw), collapse=", "), "\n")

# --- 3a. Subset to Target Variables for PCA ---
missing_vars <- setdiff(target_env_vars_current_names, names(all_variables_stack_current_raw))
if (length(missing_vars) > 0) {
  stop("The following target variables for PCA are missing from the loaded 'current' stack: ",
       paste(missing_vars, collapse=", "),
       "\nPlease check `target_env_vars_current_names` and your downloaded files/layer names.")
}
pca_input_stack_current <- all_variables_stack_current_raw[[target_env_vars_current_names]]
cat("  Subsetted to", terra::nlyr(pca_input_stack_current), "target variables for PCA model building.\n")
rm(all_variables_stack_current_raw); gc()


# --- 3b. Apply Indo-Pacific Crop (if configured) to the SUBSETTED stack ---
pca_variables_stack_current_cropped <- pca_input_stack_current # Start with the subsetted stack
if (config$apply_indo_pacific_crop) {
  cat("  Applying Indo-Pacific crop to the selected", terra::nlyr(pca_input_stack_current), "variables...\n")
  ip_extent <- terra::ext(config$indo_pacific_bbox)
  pca_variables_stack_current_cropped <- tryCatch({
    terra::crop(pca_input_stack_current, ip_extent)
  }, error = function(e) {
    warning("Failed to crop selected current stack: ", e$message, call. = FALSE)
    pca_input_stack_current # Return uncropped if error
  })
  if(terra::ext(pca_variables_stack_current_cropped) != terra::ext(pca_input_stack_current)) {
    cat("  Selected stack successfully cropped.\n")
  } else {
    cat("  Selected stack extent unchanged after cropping (already within or error occurred).\n")
  }
} else {
  cat("  Skipping Indo-Pacific crop for selected current stack.\n")
}
rm(pca_input_stack_current); gc() # Remove uncropped subsetted stack


# Store the ORIGINAL names (of the selected variables) used to build the PCA model
# These are the `target_env_vars_current_names`
pca_variable_names_original_selected <- names(pca_variables_stack_current_cropped)
# Safety check:
if(!identical(sort(pca_variable_names_original_selected), sort(target_env_vars_current_names))) {
  warning("Mismatch between expected target variable names and names in the cropped stack for PCA. This might indicate an issue.")
  print(paste("Expected (sorted):", paste(sort(target_env_vars_current_names), collapse=", ")))
  print(paste("Actual (sorted):", paste(sort(pca_variable_names_original_selected), collapse=", ")))
}


# --- 4. Create Sampling Mask & Sample Background Points (from the CROPPED SELECTED stack) ---
n_pca_points <- config$pca_background_points_n
cat("--- Preparing sampling area and sampling", n_pca_points, "points for PCA (from selected & cropped vars) ---\n")

sampling_layer <- pca_variables_stack_current_cropped[[1]] # Use first layer of the selected, cropped stack
# ... (rest of the masking and sampling logic remains the same, as it operates on sampling_layer and then extracts from pca_variables_stack_current_cropped) ...
# Apply Coral Mask (if configured)
sampling_mask <- NULL # Initialize mask
if (config$mask_background_points_to_coral && config$apply_coral_mask) {
  cat("  Applying coral reef mask for background point sampling...\n")
  if (!is.null(config$coral_shapefile) && file.exists(config$coral_shapefile)) {
    coral_areas_sf <- tryCatch({ sf::st_read(config$coral_shapefile, quiet = TRUE) }, error = function(e) {warning(" Failed load coral shapefile:", e$message, call.=FALSE); NULL})
    if (!is.null(coral_areas_sf)) {
      coral_areas_vect <- tryCatch({ terra::vect(coral_areas_sf) }, error = function(e) {warning(" Failed convert coral sf to vect:", e$message, call.=FALSE); NULL})
      if (!is.null(coral_areas_vect)) {
        if(terra::crs(coral_areas_vect) != terra::crs(sampling_layer)){
          cat("    Projecting coral shapefile CRS to match raster...\n")
          coral_areas_vect <- tryCatch(terra::project(coral_areas_vect, terra::crs(sampling_layer)), error = function(e){warning(" Failed project coral shapefile:", e$message, call.=FALSE); NULL})
        }
        if(!is.null(coral_areas_vect)){
          sampling_mask_layer <- tryCatch(terra::mask(sampling_layer, coral_areas_vect), error=function(e){warning(" Failed mask sampling layer:", e$message, call.=FALSE); NULL}) # Changed variable name here
          if(!is.null(sampling_mask_layer)) {
            sampling_mask <- sampling_mask_layer # Assign to sampling_mask
            cat("  Coral reef mask applied for sampling.\n")
          } else {
            warning("  Failed to create sampling mask. Sampling from unmasked layer.", call.=FALSE)
            sampling_mask <- sampling_layer # Fallback
          }
        } else { warning("  CRS projection failed. Sampling from unmasked layer.", call.=FALSE); sampling_mask <- sampling_layer }
      } else { warning("  sf to vect conversion failed. Sampling from unmasked layer.", call.=FALSE); sampling_mask <- sampling_layer }
    } else { warning("  Coral shapefile loading failed. Sampling from unmasked layer.", call.=FALSE); sampling_mask <- sampling_layer }
  } else { warning("  Coral shapefile path missing/invalid. Sampling from unmasked layer.", call.=FALSE); sampling_mask <- sampling_layer }
} else {
  cat("  Background point sampling not masked to coral reefs.\n")
  sampling_mask <- sampling_layer
}

set.seed(123)
bg_points_for_pca <- terra::spatSample(sampling_mask, size = n_pca_points, method = "random", na.rm = TRUE, xy = TRUE, warn = FALSE)
if (nrow(bg_points_for_pca) < n_pca_points) { warning("Sampled fewer points (", nrow(bg_points_for_pca), ") than requested (", n_pca_points, ") for PCA (likely due to mask).", call.=FALSE) }
if (nrow(bg_points_for_pca) == 0) stop("Failed to sample any valid points for PCA.")
cat("  Sampled", nrow(bg_points_for_pca), "points from the designated sampling area.\n")
rm(sampling_layer, sampling_mask); gc()

cat("  Extracting values from the SELECTED & CROPPED stack at sampled points for PCA model building...\n")
bg_values_df <- terra::extract(pca_variables_stack_current_cropped, bg_points_for_pca[, c("x","y")], ID = FALSE)
bg_values_df <- na.omit(bg_values_df)

if (nrow(bg_values_df) < config$n_pca_components) { stop("Insufficient non-NA data rows (", nrow(bg_values_df), ") for PCA with ", config$n_pca_components, " components.") }
if (ncol(bg_values_df) != length(pca_variable_names_original_selected)) {
  stop("Mismatch between columns in extracted values and the selected variables for PCA. Extracted: ", ncol(bg_values_df), ", Expected: ", length(pca_variable_names_original_selected))
}
cat("  Using", nrow(bg_values_df), "complete cases for PCA model from", ncol(bg_values_df), "selected variables.\n")
# DO NOT clean up pca_variables_stack_current_cropped yet, needed if projection is done on current scenario too.
# rm(bg_points_for_pca); gc() # Only remove points for now

# --- 5. Perform PCA on CURRENT Data (from the 8 selected variables) ---
cat("--- Performing PCA on scaled data from the", ncol(bg_values_df), "selected current environmental variables ---\n")
bg_values_scaled <- scale(bg_values_df, center = TRUE, scale = TRUE) # bg_values_df now only has the 8 selected vars
pca_model <- tryCatch({ stats::prcomp(bg_values_scaled) }, error = function(e) { warning("PCA calculation failed: ", e$message, call. = FALSE); NULL })
if(is.null(pca_model)) stop("PCA failed.")
rm(bg_values_df, bg_values_scaled, bg_points_for_pca); gc() # Now safe to remove points

pca_model_save_path <- config$pca_models_rds_path
dir.create(dirname(pca_model_save_path), showWarnings = FALSE, recursive = TRUE)
tryCatch({ saveRDS(pca_model, file = pca_model_save_path); cat("  PCA model object (built from selected vars) saved to:", pca_model_save_path, "\n")}, error = function(e) { stop("Failed to save PCA model object: ", e$message) })

# PCA Summary and Plots (will reflect the PCA on selected vars)
# ... (plotting code remains the same) ...
pca_summary <- summary(pca_model); print(pca_summary)
pca_variance_path <- file.path(config$log_dir_base, "pca_variance_explained_plot_selected_vars.png") # New name
tryCatch({ png(pca_variance_path, width=8, height=6, units="in", res=300); plot(pca_model, type = "l", main = "PCA Variance Explained (Selected Vars)"); abline(h=0.9, col="red", lty=2); text(x = length(pca_model$sdev), y = 0.95, labels = "90% Variance", col = "red", pos = 1); dev.off(); cat("  PCA variance explained plot saved to:", pca_variance_path, "\n")}, error = function(e) { warning("Failed save PCA variance plot: ", e$message, call.=FALSE)})
pca_biplot_path <- file.path(config$log_dir_base, "pca_biplot_PC1_PC2_selected_vars.png") # New name
tryCatch({ png(pca_biplot_path, width=8, height=8, units="in", res=300); biplot(pca_model, choices = 1:2, scale = 0, cex = 0.7); title("PCA Biplot (PC1 vs PC2 - Selected Vars)"); dev.off(); cat("  PCA biplot saved to:", pca_biplot_path, "\n")}, error = function(e) { warning("Failed save PCA biplot: ", e$message, call.=FALSE)})


# --- 6. Project PCA onto Rasters for ALL Scenarios (With Cropping and Subsetting) ---
cat("\n--- Projecting PCA model (built from selected vars) onto rasters for all scenarios ---\n")
pca_raster_paths_list <- list()

for(scenario in config$env_scenarios) {
  cat("  -- Projecting scenario:", scenario, "--\n")
  
  # Load the *full* environmental stack for this specific scenario
  # This stack contains ALL variables initially loaded by load_stack_env_data
  scenario_stack_raw_full <- load_stack_env_data(scenario, config)
  if(is.null(scenario_stack_raw_full)){ warning("Could not load full stack for scenario '", scenario, "'. Skipping projection.", call.=FALSE); next }
  
  # Apply Indo-Pacific Crop (if configured) to the full stack
  scenario_stack_cropped_full <- scenario_stack_raw_full
  if (config$apply_indo_pacific_crop) {
    cat("    Applying Indo-Pacific crop to full scenario stack...\n")
    ip_extent <- terra::ext(config$indo_pacific_bbox)
    scenario_stack_cropped_full <- tryCatch({ terra::crop(scenario_stack_raw_full, ip_extent) },
                                            error = function(e) { warning(" Failed crop full stack: ", e$message, call. = FALSE); scenario_stack_raw_full })
    if(terra::ext(scenario_stack_cropped_full) != terra::ext(scenario_stack_raw_full)) { cat("    Full stack cropped.\n")} else { cat("    Full stack extent unchanged after crop.\n")}
  } else { cat("    Skipping Indo-Pacific crop for full scenario stack.\n") }
  rm(scenario_stack_raw_full); gc()
  
  # *** Generate the EXPECTED variable names for THIS scenario FROM THE ORIGINAL SELECTED LIST (`target_env_vars_current_names`) ***
  # These are the 8 (or so) variables that the PCA model was built upon.
  expected_vars_for_scenario_subset <- generate_scenario_variable_list(target_env_vars_current_names, scenario, config)
  
  # Check if all EXPECTED SUBSET variables are present in the loaded (and possibly cropped) FULL stack for this scenario
  if (!all(expected_vars_for_scenario_subset %in% names(scenario_stack_cropped_full))) {
    missing_projection_vars_subset <- expected_vars_for_scenario_subset[!expected_vars_for_scenario_subset %in% names(scenario_stack_cropped_full)]
    warning("The following SELECTED variables needed for PCA projection are MISSING from the loaded/cropped full stack for scenario '", scenario, "':\n  ",
            paste(missing_projection_vars_subset, collapse=", "), "\nCannot project PCA. Skipping scenario.", call.=FALSE)
    print(paste("Available layers in scenario_stack_cropped_full:", paste(names(scenario_stack_cropped_full), collapse=", ")))
    rm(scenario_stack_cropped_full); gc(); next
  }
  
  # Subset the (cropped) full stack to ONLY the variables corresponding to those used in PCA model building
  scenario_stack_for_projection <- scenario_stack_cropped_full[[expected_vars_for_scenario_subset]]
  rm(scenario_stack_cropped_full); gc()
  cat("    Subsetted scenario stack to", terra::nlyr(scenario_stack_for_projection), "variables for PCA projection.\n")
  
  # *** RENAME the subsetted stack layers back to the ORIGINAL (current) names used for PCA model building ***
  # `pca_variable_names_original_selected` holds the 'current' names of the 8 vars.
  if (terra::nlyr(scenario_stack_for_projection) == length(pca_variable_names_original_selected)) {
    names(scenario_stack_for_projection) <- pca_variable_names_original_selected
    cat("    Renamed scenario stack layers for projection to match original PCA variable names:", paste(pca_variable_names_original_selected, collapse=", "), "\n")
  } else {
    warning("Mismatch in layer count after subsetting for scenario '", scenario, "' (Expected: ", length(pca_variable_names_original_selected), ", Got: ", terra::nlyr(scenario_stack_for_projection), "). Cannot reliably rename for projection. Skipping.", call. = FALSE)
    rm(scenario_stack_for_projection); gc(); next
  }
  
  # Project using terra::predict
  pca_raster_scenario <- tryCatch({
    terra::predict(scenario_stack_for_projection, pca_model, index = 1:config$n_pca_components)
  }, error = function(e){
    warning("terra::predict failed for scenario '", scenario, "': ", e$message, call.=FALSE)
    return(NULL)
  })
  
  if (is.null(pca_raster_scenario)) {
    warning("PCA projection failed for scenario '", scenario, "'. Skipping.", call.=FALSE)
    rm(scenario_stack_for_projection); gc()
    next
  }
  
  names(pca_raster_scenario) <- paste0("PC", 1:config$n_pca_components)
  pca_raster_filename <- paste0("pca_rasters_", scenario, "_selected_vars.tif") # New name
  pca_raster_save_path <- file.path(config$log_dir_base, pca_raster_filename)
  
  tryCatch({
    terra::writeRaster(pca_raster_scenario, filename = pca_raster_save_path, overwrite = TRUE, gdal=c("COMPRESS=LZW", "TFW=YES"))
    cat("    PCA raster stack (from selected vars) saved for scenario '", scenario, "' to:", pca_raster_save_path, "\n")
    pca_raster_paths_list[[scenario]] <- pca_raster_save_path
  }, error = function(e) {
    warning("Failed to write PCA raster for scenario '", scenario, "': ", e$message, call.=FALSE)
  })
  
  rm(scenario_stack_for_projection, pca_raster_scenario); gc()
} # End scenario loop

# --- Clean up the initially cropped stack for current scenario (used for PCA model building) ---
if(exists("pca_variables_stack_current_cropped")) rm(pca_variables_stack_current_cropped); gc()


# --- 7. Save the List of PCA Raster Paths ---
pca_paths_rds_save_path <- config$pca_raster_paths_rds_path # This path is fine, it will now point to PCA from selected vars
if (length(pca_raster_paths_list) > 0) {
  tryCatch({ saveRDS(pca_raster_paths_list, file = pca_paths_rds_save_path)
    cat("--- List of PCA raster paths (from selected vars) saved to:", pca_paths_rds_save_path, "---\n") },
    error = function(e){ warning("Failed to save PCA raster paths list: ", e$message, call.=FALSE) })
} else { warning("No PCA rasters (from selected vars) generated/saved. Paths list empty.", call.=FALSE) }

cat("--- Script 05_preprocess_env_pca_only.R (v4 - Selected Vars) finished. ---\n")
#-------------------------------------------------------------------------------