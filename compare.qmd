---
title: "Anemonefish Mutualism Analysis Results"
format: html
editor: visual
execute:
  echo: true
  warning: false
  message: false
---

# Drivers of Host Sea Anemone and Anemonefish Richness

This section replicates the initial data loading and processing steps from the desert ant paper's results section, adapted for the anemonefish-anemone mutualism. We load the current predicted suitability rasters for host sea anemones and anemonefish (environmental-only models), calculate community richness, and crop them to the Indo-Pacific study area.

```{r setup-libraries-and-config}
#| label: setup-libraries-and-config
#| message: false
#| warning: false

# Using pacman for streamlined package management
if (!require("pacman")) install.packages("pacman")
pacman::p_load(here, dplyr, terra, sf, stringr, ggplot2, readr, tools, naturalearth, tidyterra)

# Load project configuration
# Ensure your working directory is the root of your sdm_anemonefish project
if (file.exists("scripts/config.R")) {
  source("scripts/config.R")
} else if (file.exists(here::here("scripts/config.R"))) {
  source(here::here("scripts/config.R"))
} else {
  stop("FATAL: Configuration file 'scripts/config.R' not found. Please set your working directory to the project root.")
}
if (!exists("config")) stop("FATAL: 'config' list not found after sourcing config.R")

# Helper function for constructing prediction filenames (already in your sdm_modeling_helpers.R)
# Make sure this helper is sourced or defined if not running the full pipeline before this
# NOTE: The original construct_prediction_filename will be REPLACED or adapted below for depth parsing.
# You might still need your sdm_modeling_helpers.R for other reasons, keep it for now.
# source(file.path(config$helpers_dir, "sdm_modeling_helpers.R")) # If needed


# --- Create Essential Output Directories ---
analysis_output_dir <- file.path(config$base_dir, "outputs_for_analysis")
if (!dir.exists(analysis_output_dir)) {
  dir.create(analysis_output_dir, recursive = TRUE)
  cat("Created directory for analysis outputs at:", analysis_output_dir, "\n")
}

figure_output_dir <- file.path(config$base_dir, "figure_files")
if (!dir.exists(figure_output_dir)) {
  dir.create(figure_output_dir, recursive = TRUE)
  cat("Created directory for figures at:", figure_output_dir, "\n")
}

cat("--- Setup: Essential output directories checked/created. ---\n")


# --- Scenario Label Converter (Good to have this defined early) ---
# This might be less relevant for pure depth comparisons, but keep it for consistency if needed elsewhere.
scenario_label_converter <- c(
  "current"       = "Current",
  "ssp119_2050" = "SSP1-1.9 (2050)",
  "ssp119_2100" = "SSP1-1.9 (2100)",
  "ssp245_2050" = "SSP2-4.5 (2050)", 
  "ssp245_2100" = "SSP2-4.5 (2100)", 
  "ssp370_2050" = "SSP3-7.0 (2050)", 
  "ssp370_2100" = "SSP3-7.0 (2100)", 
  "ssp585_2050" = "SSP5-8.5 (2050)",
  "ssp585_2100" = "SSP5-8.5 (2100)"
)
cat("--- Setup: Scenario label converter defined. ---\n")

# --- Load a world map for plotting ---
world_map_sf <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf")
cat("--- Setup: World map loaded for plotting. ---\n")

# --- NEW: Load the Global Bathymetry Raster ---
# IMPORTANT: Replace "path/to/your/global_bathymetry.tif" with the actual path to your bathymetry data.
# This should be a raster where cell values represent depth (e.g., positive values for depth).
# Adjust depth threshold based on how your bathymetry data is represented (e.g., negative for depth).
# Assuming positive values for depth (0 at surface, increasing with depth)
bathymetry_raster_path <- file.path(config$base_dir, "data", "env", "terrain", "bathymetry_mean.tif") # Example path
if (!file.exists(bathymetry_raster_path)) {
  stop("FATAL: Bathymetry raster not found at specified path. Please update 'bathymetry_raster_path' in config or directly in this chunk.")
}
global_bathymetry <- terra::rast(bathymetry_raster_path)
cat("--- Setup: Global bathymetry raster loaded. ---\n")
```

```{r define-plotting-function-v2}
#| label: define-plotting-function-v2
#| echo: false

# Reusable function to create publication-quality prediction maps
# MODIFIED to accept and plot occurrence points
plot_prediction_map <- function(prediction_raster, species_name, world_basemap, occurrence_points_sf = NULL, title_suffix = "") {
  
  # Ensure the raster has a name for the legend
  names(prediction_raster) <- "Suitability"
  
  # Define the color scale to match the example
  custom_color_scale <- scale_fill_gradientn(
    colors = c("#FFFFFF", "#FEF9C3", "#FDBA74", "#D946EF", "#4F46E5"),
    na.value = "transparent",
    limits = c(0, 1),
    name = "Occurrence\nprobability"
  )
  
  # Create the plot using ggplot2 and tidyterra
  p <- ggplot() +
    # 1. Add the world map as the base layer
    geom_sf(data = world_basemap, fill = "grey80", color = "white", linewidth = 0.2) +
    
    # 2. Add the prediction raster on top
    geom_spatraster(data = prediction_raster, aes(fill = Suitability)) +
    
    # 3. Apply the custom color scale
    custom_color_scale
  
  # --- NEW: Add occurrence points if they are provided ---
  if (!is.null(occurrence_points_sf) && inherits(occurrence_points_sf, "sf") && nrow(occurrence_points_sf) > 0) {
    p <- p + geom_sf(data = occurrence_points_sf, 
                      color = "black", 
                      fill = "yellow", # A fill color makes points more visible
                      shape = 21,      # A shape with a border and fill
                      size = 1.5,      # Adjust size as needed
                      stroke = 0.2,    # Thickness of the point border
                      alpha = 0.7)
  }
  # --- END NEW ---
  
  # 4. Set map projection and limits to the extent of the raster
  p <- p + coord_sf(crs = sf::st_crs(prediction_raster),
                    xlim = ext(prediction_raster)[c(1,2)],
                    ylim = ext(prediction_raster)[c(3,4)],
                    expand = FALSE) +
    
    # 5. Add title and use a clean theme
    labs(title = paste0(species_name, title_suffix)) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "italic"),
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      panel.grid = element_blank(),
      panel.background = element_rect(fill = "white", color = NA),
      legend.position = "right"
    )
    
  return(p)
}
```

```{r filter-species-for-analysis}
#| label: filter-species-for-analysis
#| echo: true

# --- Master Species Lists for Analysis ---
# Comment out any species you wish to EXCLUDE from all subsequent analyses.

# -- Host Anemone Species to Include --
include_anemones <- c(
  "Entacmaea quadricolor",
  "Radianthus crispa",
  "Radianthus magnifica",
  "Stichodactyla gigantea",
  "Cryptodendrum adhaesivum",
  "Macrodactyla doreensis",
  "Stichodactyla mertensii",
  "Stichodactyla haddoni",
  "Radianthus malu",
  "Heteractis aurora"
)

# -- Anemonefish Species to Include --
include_anemonefish <- c(
  "Amphiprion clarkii",
  "Amphiprion frenatus",
  "Amphiprion ocellaris",
  "Amphiprion perideraion",
  "Amphiprion polymnus",
  "Amphiprion sandaracinos",
  "Amphiprion akallopisos",
  "Amphiprion omanensis",
  "Amphiprion akindynos",
  "Amphiprion allardi",
  "Amphiprion barberi",
  "Amphiprion bicinctus",
  "Amphiprion chagosensis",
  "Amphiprion chrysogaster",
  "Amphiprion chrysopterus",
  "Amphiprion ephippium",
  "Amphiprion fuscocaudatus",
  "Amphiprion latezonatus",
  "Amphiprion latifasciatus",
  "Amphiprion leucokranos",
  "Amphiprion mccullochi",
  "Amphiprion melanopus",
  "Amphiprion nigripes",
  "Amphiprion percula",
  "Amphiprion rubrocinctus",
  "Amphiprion sebae",
  "Amphiprion tricinctus",
  "Premnas biaculeatus",
  "Amphiprion pacificus"
)

# --- Load and Filter the Main Data Frames ---
# This part reads the full CSVs (created by script 02) and filters them.
# The filtered data frames will be used by all subsequent chunks.

# Load Anemones
anemone_species_df_full <- readr::read_csv(config$anemone_species_list_file, show_col_types = FALSE)
anemone_species_df <- anemone_species_df_full %>%
  filter(scientificName %in% include_anemones)

cat(sprintf("Filtered Host Anemones: Retaining %d of %d species for analysis.\n", 
            nrow(anemone_species_df), nrow(anemone_species_df_full)))


# Load Anemonefish
anemonefish_species_df_full <- readr::read_csv(config$anemonefish_species_list_file, show_col_types = FALSE)
anemonefish_species_df <- anemonefish_species_df_full %>%
  filter(scientificName %in% include_anemonefish)

cat(sprintf("Filtered Anemonefish: Retaining %d of %d species for analysis.\n",
            nrow(anemonefish_species_df), nrow(anemonefish_species_df_full)))
```

# FINAL PLOTS

```{r depth-comparison-plots}
#| label: depth-comparison-plots
#| fig-width: 12
#| fig-height: 8 # Adjust height as needed for multiple panels

# Define the base directory for predictions
prediction_base_dir <- "/home/bi-server-kyoto/a0236995/sdm_anemonefish/data/output/predictions"

# Get all .tif files, excluding those in the 'Future' subdirectory
prediction_files <- list.files(
  path = prediction_base_dir,
  pattern = "\\.tif$",
  full.names = TRUE,
  recursive = FALSE # Only list files directly in the prediction_base_dir, not 'Future/'
)

# Filter out future prediction files if they somehow get included (based on your 'ls -la' output)
prediction_files <- prediction_files[!grepl("Future", prediction_files)]

# Data frame to store file info for easier processing
file_info <- data.frame(
  path = prediction_files,
  stringsAsFactors = FALSE
) %>%
  mutate(
    filename = basename(path),
    # Extract depth using regex. Assumes depth is a number followed by '_pred_'
    # depth = as.numeric(str_extract(filename, "^mean(?=_pred_)")),
    # Extract species name
    species_raw = str_replace(filename, "mean_pred_", ""),
    species_name_sanitized = str_replace(species_raw, "_pca\\.tif$", ""),
    species_name_clean = gsub("_", " ", species_name_sanitized)
  ) %>%
  # Filter out rows where depth or species name couldn't be parsed correctly
  filter(species_name_sanitized != "") %>%
  # Filter to only include species from your master lists
  filter(species_name_clean %in% c(include_anemones, include_anemonefish))

# Get unique species for plotting
unique_species <- unique(file_info$species_name_clean)
unique_depths <- sort(unique(file_info$depth))

cat(sprintf("Found predictions for %d species across %d depths: %s\n", 
            length(unique_species), length(unique_depths), paste(unique_depths, collapse = ", ")))

# --- Important: Prepare the bathymetry raster for masking ---
# Crop the global bathymetry to your plot extent or a broader Indo-Pacific extent once
# This is done once outside the loop for efficiency
if (config$apply_indo_pacific_crop) {
  mask_extent <- terra::ext(config$indo_pacific_bbox)
} else {
  # Use a reasonable default or the extent of your first prediction raster
  # This might need adjustment if your first raster is tiny
  mask_extent <- terra::ext(terra::rast(file_info$path[1])) 
}

# Ensure bathymetry matches CRS of your suitability rasters (assuming WGS84 = 4326)
# And resample it to match the resolution of your prediction rasters for accurate cell-wise masking.
# Assuming all your prediction rasters have the same CRS and resolution.
# Let's get the CRS and resolution from the first prediction raster as a reference.
if (nrow(file_info) > 0) {
    ref_raster <- terra::rast(file_info$path[1])
    target_crs <- terra::crs(ref_raster)
    target_res <- terra::res(ref_raster)
    rm(ref_raster) # Clean up
} else {
    stop("No prediction files found to determine target CRS/resolution for bathymetry.")
}

# Project and resample global_bathymetry if necessary
# Note: terra::project uses a reference raster for resolution and extent by default
# if you give it 'y' as a SpatRaster.
# We'll create a dummy raster at target_res within mask_extent for resampling.
dummy_raster_for_resample <- terra::rast(ext=mask_extent, res=target_res, crs=target_crs)

# Project and resample the bathymetry to match your prediction rasters
# 'method = "average"' or "bilinear" for continuous data, "near" for categorical
bathymetry_for_masking <- terra::project(global_bathymetry, dummy_raster_for_resample, method = "average")
cat("--- Bathymetry raster prepared for masking. ---\n")
# --- END IMPORTANT PREP ---


# Loop through each unique species and create a comparison plot across depths
for (sp_clean_name in unique_species) {
  cat(sprintf("\n--- Plotting Depth Comparison for: %s ---\n", sp_clean_name))
  
  # Filter file_info for the current species
  species_files <- file_info %>%
    filter(species_name_clean == sp_clean_name) %>%
    arrange(depth) # Ensure depths are in order for consistent plotting
  
  if (nrow(species_files) == 0) {
    cat("No prediction files found for", sp_clean_name, ". Skipping.\n")
    next
  }
  
  # Load all rasters for the current species across different depths
  raster_list <- list()
  for (i in 1:nrow(species_files)) {
    r_path <- species_files$path[i]
    # r_depth <- species_files$depth[i]
    r_depth <- 1000
    
    if (file.exists(r_path)) {
      ras <- terra::rast(r_path)
      names(ras) <- paste0("Suitability_Depth_", r_depth) # Give unique name for combining
      raster_list[[as.character(r_depth)]] <- ras
    } else {
      cat("Warning: File not found:", r_path, "\n")
    }
  }
  
  if (length(raster_list) == 0) {
    cat("No valid rasters loaded for", sp_clean_name, ". Skipping plot.\n")
    next
  }
  
  # Stack all rasters for the species
  species_depth_stack <- terra::rast(raster_list)
  
  # --- START OF REVISED CODE FOR DEPTH MASKING ---
  # Apply the depth cutoff (e.g., 500m) to each suitability layer based on the bathymetry
  # We'll iterate through each layer in the species_depth_stack
  
  # Create a new stack for masked results
  species_depth_stack_masked <- species_depth_stack 
  
  # Define the maximum allowed depth (e.g., 500m)
  max_display_depth <- -1000
  
  for (i in 1:nlyr(species_depth_stack_masked)) {
    current_suitability_layer <- species_depth_stack_masked[[i]]
    
    # IMPORTANT: The 'depth' from the filename (e.g., 1000m) is just the input depth for that SDM.
    # We want to mask based on the *actual bathymetry* values for each cell.
    
    # Mask suitability values where bathymetry is deeper than max_display_depth
    # Assuming bathymetry_for_masking values are positive (depth)
    # Use terra::mask for this conditional masking
    # if bathymetry_for_masking is NA, the output will also be NA
    # if bathymetry_for_masking > max_display_depth, suitability becomes NA
    
    # If GEBCO values are negative (elevation), adjust the condition:
    # `current_suitability_layer <- terra::mask(current_suitability_layer, bathymetry_for_masking, maskvalues = -(max_display_depth):min(values(bathymetry_for_masking), na.rm = TRUE), inverse = TRUE)`
    # This might be tricky if GEBCO has ocean values as negative and land as positive.
    # A simpler `ifel` (if-else) approach might be safer if GEBCO values are consistently negative for depth.
    
    # Let's assume GEBCO values are positive (depth). If they are negative (elevation),
    # change `bathymetry_for_masking > max_display_depth` to `bathymetry_for_masking < -max_display_depth`
    # and be mindful of land values (often positive or 0).
    
    # Using `ifel` for direct cell-wise conditional assignment:
    # If actual_depth > max_display_depth, set suitability to NA, else keep suitability.
    # We need to make sure `bathymetry_for_masking` aligns perfectly with `current_suitability_layer`.
    # Since we already projected/resampled `bathymetry_for_masking` to match, this should work.
    
    # Check for NA values in bathymetry (e.g., land) and ensure suitability is also NA there
    # This also sets values to NA if the actual depth is greater than max_display_depth
    species_depth_stack_masked[[i]] <- terra::ifel(
                                        is.na(bathymetry_for_masking) | bathymetry_for_masking < max_display_depth, 
                                        NA, 
                                        current_suitability_layer
                                      )
  }
  cat(sprintf("Applied 0-%dm depth mask to each suitability prediction layer for %s.\n", max_display_depth, sp_clean_name))
  # --- END OF REVISED CODE FOR DEPTH MASKING ---

  # Get occurrence points if available (reusing your existing logic)
  occ_sf <- NULL
  # Determine if it's an anemone or anemonefish and get AphiaID
  if (sp_clean_name %in% include_anemones) {
    aphia_id <- anemone_species_df$AphiaID[anemone_species_df$scientificName == sp_clean_name]
    occ_dir <- config$anemone_occurrence_dir
  } else if (sp_clean_name %in% include_anemonefish) {
    aphia_id <- anemonefish_species_df$AphiaID[anemonefish_species_df$scientificName == sp_clean_name]
    occ_dir <- config$anemonefish_occurrence_dir
  }
  
  if (length(aphia_id) == 1) {
    occ_file <- file.path(occ_dir, paste0(aphia_id, ".csv"))
    if (file.exists(occ_file)) {
      occ_df <- readr::read_csv(occ_file, show_col_types = FALSE) %>% filter(!is.na(decimalLongitude) & !is.na(decimalLatitude))
      if (nrow(occ_df) > 0) occ_sf <- sf::st_as_sf(occ_df, coords = c("decimalLongitude", "decimalLatitude"), crs = 4326)
    }
  }

  # Define the common extent for all plots for consistency
  if (config$apply_indo_pacific_crop) {
    plot_extent <- terra::ext(config$indo_pacific_bbox)
    # Ensure all rasters are cropped to this extent before plotting together
    # NOW USING species_depth_stack_masked
    species_depth_stack_cropped <- tryCatch(terra::crop(species_depth_stack_masked, plot_extent), 
                                            error = function(e) { 
                                              cat("Warning: Failed to crop masked stack for", sp_clean_name, ":", e$message, "\n"); 
                                              species_depth_stack_masked 
                                            })
  } else {
    # NOW USING species_depth_stack_masked
    species_depth_stack_cropped <- species_depth_stack_masked
    plot_extent <- ext(species_depth_stack_cropped) # Use the full extent if not cropping
  }
  
  # Plotting with facets for different depths
  p_depth_comparison <- ggplot() +
    geom_sf(data = world_map_sf, fill = "grey80", color = "white", linewidth = 0.2) +
    # Use after_stat(value) as corrected previously
    geom_spatraster(data = species_depth_stack_cropped, aes(fill = after_stat(value))) + 
    scale_fill_gradientn(
      colors = c("#FFFFFF", "#FEF9C3", "#FDBA74", "#D946EF", "#4F46E5"),
      na.value = "transparent",
      limits = c(0, 1),
      name = "Occurrence\nprobability"
    ) +
    # Add occurrence points to each facet if available
    {if (!is.null(occ_sf)) geom_sf(data = occ_sf, color = "black", fill = "yellow", shape = 21, size = 1, stroke = 0.2, alpha = 0.7)} +
    coord_sf(crs = sf::st_crs(species_depth_stack_cropped),
             xlim = plot_extent[c(1,2)],
             ylim = plot_extent[c(3,4)],
             expand = FALSE) +
    facet_wrap(~lyr, ncol = 2, 
               labeller = as_labeller(function(x) paste0(gsub("Suitability_Depth_", "", x), "m Prediction (0-", max_display_depth, "m Mask)"))
               ) + # Custom labels for facets, indicating both prediction depth and masking
    labs(title = paste0(sp_clean_name, " Suitability Predictions (Masked at ", max_display_depth, "m Depth)")) + # Updated title
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 16, face = "italic"),
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      panel.grid = element_blank(),
      panel.background = element_rect(fill = "white", color = NA),
      legend.position = "right",
      strip.text = element_text(size = 12, face = "bold") # Styling for facet labels
    )
  
  # Save the plot
  plot_filename_base <- gsub(" ", "_", sp_clean_name)
  depth_plot_filename <- file.path(figure_output_dir, paste0(plot_filename_base, "_depth_comparison_masked_at_", max_display_depth, "m.png")) # Updated filename
  ggsave(depth_plot_filename, plot = p_depth_comparison, width = 12, height = 8, dpi = 300, bg="white")
  cat("Saved depth comparison plot to:", depth_plot_filename, "\n")
  print(p_depth_comparison) # Display the plot
}

cat("\n--- All depth comparison plots generated and saved. ---\n")
```

# PRINT HERE

```{r}
# hello

```
